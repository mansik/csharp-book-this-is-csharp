# 파일 업로드 프로토콜(FUP로 명명 : File Upload Protocol)

> `C# 으로만 이루어진 애플리케이션과 통신할 거라면 이런 복잡한 프로토콜보다는 직렬화가 더 적합하다.`  
> 하지만 대개의 경우, 통신 애플리케이션은 자신과 상이한 환경에서 이미 터를 잡고 동작하고 있으므로  
> 그에 맞춰서 직접 프로토콜을 구현해야 한다. 이것은 그러한 환경을 위한 예제이다.

> 여기서 사용하는 스트림은 NetworkStream이며, stream.Read()의 반환값이 0은 바

# 코딩 순서

1. 프로토콜 설계 (헤더, 바디의 구조)
2. 서버/클라이언트 공용 클래스 라이브러리 구현(메시지, 헤더, 바디, 메시지 전송부)
3. 서버 구현
4. 클라이언트 구현

# 프로토콜 설계

1. 프로토콜은 헤더와 바디로 구성
2. `바디에는 실제 전달하고자 하는 데이터를 담고,`
3. `헤더에는 본문 길이를 비롯해 메시지의 속성 몇 가지를 담는다.`
4. 바디의 길이는 담는 데이터에 따라 달라지지만
5. `헤더의 길이는 16바이트로 항상 일정하다.`
6. 수신한 패킷을 분석할 때는 가장 먼저 16바이트를 먼저 확인해서 (바디의 길이를 포함한) 메시지의 속성을 확인하고
7. 그 다음에 바디의 길이만큼을 또 읽어 하나의 메시지를 끝을 끊어낸다.


## 프로토콜 구조 (가변 길이 형식 중 메시지를 두 부분으로 나누는 방식 채택)

 |     헤더      |   | 16바이트 |
 | ---           |---| ---      |
 |     바디      |   | n 바이트 |


## 헤더 구조 ( 16bytes)

 |          4 bytes           |
 |        :---------:         |
 |          MSGID             |
 |         MSGTYPE            |
 |         BODYLEN            |

 | FRAGMENT | LASTMSG |  SEQ  |
 |  ---     |   ---   |  ---  |
 | 1byte    | 1byte   | 2byte |

 
# 패킷의 경계를 구분하는 방법(고정 길이 & 가변 길이)

- `스트림에서 패킷의 경계를 구분해내는 일은 TCP 네트워크 프로그래밍에서 필수적이다.`
- 패킷의 경계를 구분하는 방법은 메시지 포맷을 설계할 때 고려해야 하는데 
- 대표적인 방법이 고정 길이 형식과 가변 길이 형식이다.

- `고정 길이 형식`에서는 모든 메시지가 같은 길이를 갖는다.
- 16바이트면 16바이트씩만, 32바이트면 32바이트씩만 잘라낸다.
- 구현하기는 간편하지만, 대역폭이 낭비될 가능성이 높다는 단점이 있다.

- `가변 길이 형식`에는 흔히 두 가지 방식을 사용한다.
- `메시지를 두 부분으로 나눠서 길이가 고정된 앞부분에 뒷부분의 길이를 기입하는 방식`과
- `메시지를 구분하는 특정 값(''라던가 캐리지 리턴 등)을 이용하는 방식`이 있다.
- `후자의 경우에는 텍스트 방식의 통신`에 주로 이용되고,
- `전자는 바이너리 통신`에 이용된다.

* 이 프로젝트는 가변 길이 형식에서도 전자에 해당한다.


# FUP의 헤더가 갖고 있는 각 속성 필드에 대한 설명

|    필드 이름    | 크기(바이트) | 설명                                   |
| ---             | ---          | --- |
| MSGID           | 4            | 메시지 식별 번호   |
| MSGTYPE         | 4            | 메시지의 종류  (0x01: 파일 전송 요청, 0x02: 파일 전송 요청에 대한 응답, 0x03: 파일 전송 데이터, 0x03: 파일 수신 결과  |
| BODYLEN         | 4            | 메시지 본문의 길이(단위: 바이트)  |
| FRAGMENTED      | 1            | 메시지의 분할 여부 (미분할: 0x00, 분할: 0x01 )  |
| LASTMSG         | 1            | 분할된 메시지가 마지막인지 여부(마지막 아님: 0x00, 마지막: 0x01)  |
| SEQ             | 2            | 메시지의 파편 번호  |

# FUP의 바디에 대한 설명

- FUP의 바디는 4가지이다.  
- 헤더의 MSGTYPE이 가질 수 있는 값이 모두 네개(0x01, 0x02, 0x03, 0x04)이므로 바디의 종류도 네 가지로 나뉜다.  

## MSGTYPE이 파일 전송 요청(0x01)인 경우의 바디 구조

- 클라이언트에서 사용
- 파일의 크기와 파일의 이름으로 구성

|    필드 이름    | 크기(바이트)     | 설명                                   |
| ---             | ---              | ---                                    |
| FILESIZE        | 8                | 전송할 파일의 크기(단위: 바이트)       |
| FILENAME        | BODYLEN-FILESIZE | 전송할 파일의 이름                     |

## MSGTYPE이 파일 전송 요청에 대한 응답(0x02)인 경우의 바디 구조

- 서버에서 사용
- 클라이언트에서 보낸 파일 전송 요청(Ox01) 메시지의 메시지 식별 번호와 같이 결과를 클라이언트로 전송

|    필드 이름    | 크기(바이트)     | 설명                                   |
| ---             | ---              | ---                                    |
| MSGID           | 4                | 파일 전송 요청 메시지(Ox01)의 메시지 식별 번호       |
| RESPONSE        | 1                | 파일 전송 승인 여부(거절: 0x00, 승인: 0x01)            |

## MSGTYPE이 파일 전송 데이터(0x03)인 경우의 바디 구조

- 클라이언트에서 사용
- 파일 전송 요청에 대한 응답(0x02) 메시지의 RESPONSE 필드가 0x1을 담고 클라이언트에 돌아오면, 
- 클라이언트는 파일 전송을 개시한다.
- 클라이언트의 파일은 네트워크 전송에 알맞도록 잘 쪼개져서 파일 전송 데이터(0x03) 메시지에 담겨 서버로 날아간다.
- 이 경우 FUP의 바디는 DATA만 담는다.
- **한번에 보낼 수 있는 크기는 `헤더의 BODYLEN`가 4바이트(4096비트)이므로 4096개의 바이트 배열에 담아 보낸다.**

|    필드 이름    | 크기(바이트)     | 설명                                   |
| ---             | ---              | ---                                    |
| DATA            | 헤더의 BODYLEN   | 파일 내용                              |

## MSGTYPE이 파일 수신 결과(0x04)인 경우의 바디 구조

- 서버에서 사용
- 클라이언트가 마지막 파일 데이터를 전송할 때는 파일 전송 데이터 메시지 헤더의 LASTMSG 필드에 0x01을 담아 보낸다.
- 마지막 파일 전송 데이터 메시지를 수신한 서버는 파일이 제대로 수신됐는지를 확인해서 파일 수신 결과(0x04) 메시지를 클라이언트에 보낸다.
- 이때 메시지 바디에는 파일 전송 데이터(0x03) 메시지의 MSGID와 파일 수신 결과가 함께 담긴다.

|    필드 이름    | 크기(바이트)     | 설명                                   |
| ---             | ---              | ---                                    |
| MSGID           | 4                | 파일 전송 데이터(0x03) 메시지의 식별 번호       |
| RESULT          | 1                | 파일 전송 성공 여부(실패: 0x00, 성공: 0x01)     |